[% setvar title Request For New Pragma: Shell %]
<div id="archive-notice">
    <h3>This file is part of the Perl 6 Archive</h3>
    <table bgcolor="red"><tr><td><font color="white"> Note: these documents may be out of date. Do <b>not</b> use as reference!</font></tr></td></table>
    <p>To see what is currently happening visit <a href="http://www.perl6.org/">http://www.perl6.org/</a></p>
</div>
<div class='pod'>
<a name='TITLE'></a><h1>TITLE</h1>
<p>Request For New Pragma: Shell</p>
<a name='VERSION'></a><h1>VERSION</h1>
<pre>  Maintainer: Bryan C. Warnock &lt;<a href='mailto:bwarnock@gtemail.net'>bwarnock@gtemail.net</a>&gt;
  Date: 5 Aug 2000
  Last Modified: 18 Sep 2000
  Mailing List: <a href='mailto:perl6-language@perl.org'>perl6-language@perl.org</a>
  Number: 42
  Version: 3
  Status: Frozen
  Frozen since: v2</pre>
<a name='CHANGES'></a><h1>CHANGES</h1>
<p>Added the heavy footnoting about name-clobbering with <code>Shell.pm</code>.</p>
<a name='ABSTRACT'></a><h1>ABSTRACT</h1>
<p>Perl 6 should add a new pragma, previously thought to be called <code>shell</code>, but
now called something else, although I don't know what.  So I'll stick with
<code>shell</code>.  Although quite frankly <code>Bob</code> would be just fine with me.</p>
<a name='DESCRIPTION'></a><h1>DESCRIPTION</h1>
<p>The shell that Perl uses for shell interpretation is defined at compile
time.  Furthermore, it is optimized away when no metacharacters are found
within the command string.</p>
<p>There are times when one may need (or desire) to change the shell used for
interpretation, as well as force shell interpretation, regardless of
optimization, for consistency's sake.</p>
<p>Perl runs on many platforms.  Many of these platforms, either by default,
desire, or need, may have multiple command interpreters that Perl may want to
interface with by default.  (ie, through the use of backticks or system().)</p>
<p>Perl is not just a glue language, but a SuperGlue language.  I ab^H^Huse
Perl to interact with a lot of home-grown command interpreters as either a
driver, a hardware controller, or Expect-type engine.  It's a lot more
DWIMmer when I can operate in that environment, vice the standard OS one.</p>
<p>Furthermore, there are times when speed be damned!  I need every `` to go
through the command interpreter in order to get back consistent results,  and
I don't want to have to mangle the output string in order to force a
metacharacter.</p>
<p>It is important, however, that this be lexically scoped.  One can't really
afford to have some unknown module expect /bin/sh and accidentally send the
command to turn on a robot's &quot;Kill Human&quot; mode, for instance.</p>
<a name='MOTIVATORS'></a><h1>MOTIVATORS</h1>
<p>Laziness, and perhaps a bit of Hubris.</p>
<a name='IMPLEMENTATION'></a><h1>IMPLEMENTATION</h1>
<p>This was an easy hack in Perl 5, except for the scoping issue.  Ideally,
there'd be a -force flag to check, and a method to change the location of the
shell, the shell arguments, and perhaps what is defined as a shell
metacharacter.</p>
<a name='SUMMARY OF IMPLEMENTATION'></a><h2>SUMMARY OF IMPLEMENTATION</h2>
<p>See above.  I hacked this for Perl 5 in about two minutes, minus the scoping,
which I never could figure out.  :-(  The scoping lament is continued in RFC
40.</p>
<a name='IMPACT'></a><h2>IMPACT</h2>
<ul>
<li><a name='Impact on Perl 5. Mutual compatibility between Perl 5 and Perl 6, with the exception of use shell and the semantics it would add. (Obviously, other changes to the language notwithstanding.)'></a>Impact on Perl 5.  Mutual compatibility between Perl 5 and Perl 6, with the
exception of <code>use shell</code> and the semantics it would add.  (Obviously,  other
changes to the language notwithstanding.)</li>
</ul>
<a name='UNKNOWNS'></a><h2>UNKNOWNS</h2>
<ul>
<li><a name='What if the interfaced modules return things that `` and system() don't expect?'></a>What if the interfaced modules return things that `` and system() don't
expect?</li>
</ul>
<a name='STATUS'></a><h1>STATUS</h1>
<p>Frozen.  There has been little discussion, other than pointing out that Shell
is already a module, and on platforms that are case insensitive, the
two would clobber.  Furthermore, it was agreed that this <code>shell</code>
doesn't fit well into that <code>Shell</code>.  Hence, this pragma is more or
less the ubiquitous &quot;player to be named later.&quot;</p>
<a name='REFERENCES'></a><h1>REFERENCES</h1>
<p>RFC 40: Module Scope Control.</p>
</div>
